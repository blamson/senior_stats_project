---
title: "Creating Model"
author: "Brady Lamson"
format: pdf
---

# Import Packages

```{r}
library(stringr)
library(dplyr)
library(skimr)
library(readxl)
library(glue)
library(ggplot2)
library(tidyr)
library(readr)
source('../helpers.R')
library(skimr)
```

# Import Data

```{r}
load_preprocessed <- TRUE

data_date <- "data/sep_13"

if (load_preprocessed) {
    data_path <- "pompei_preprocessed.csv"
    full_path <- paste0("../", data_date, "/", data_path)
    df <- readr::read_csv(full_path)
} else {
    data_path <- "Pompeii data 2023 for stats .xlsx"
    full_path <- paste0(data_date, "/", data_path) 
    df <- readxl::read_excel(full_path, sheet="all peristyles")
    df <- fix_variable_names(df)
    df <- create_unique_id(df)
}

df
```

# Cleaning Required Columns

The columns we'll want to include in our model are as follows:

- Visibility from entrance
- Peristyle Size
- Column Material (stone/masonry boolean)
- Widest Walkway orientation
- Direction of Entrance
- Major Axis of Garden
- Orientation of large room (large room on axis)

## Visibility from entrance

### Possible Values

```{r}
df$`visible_from_entrance?` %>% unique()
```

We can make this a quick yes/no boolean


```{r}
df <- 
    df %>% 
    mutate(
        visible_from_entrance = pattern_to_bool(string=`visible_from_entrance?`, pattern="yes")
    )

df %>% select(c(`visible_from_entrance?`, visible_from_entrance))
```

## Peristyle size

```{r}
df$peristyle_size
```

This column is already totally usable.

## Column Material

This one requires some love, every row is unique text basically. We only care if a column has either stone or masonry and will design a boolean around that.

```{r}
df$column_material %>% head()
```

```{r}

df <- 
    df %>% 
    mutate(
        stone_used_in_column = pattern_to_bool(string=column_material, pattern="(stone|masonry)")
    )

df %>% select(c(stone_used_in_column, column_material))
```

## Widest Walkway Orientation

```{r}
df$widest_walkway_dir %>% unique()
```

Here I think the best call is to create 4 dummy variables much like for walkways and peristyles

```{r}
df <- 
    df %>%
    mutate(
        widest_walkway_N = pattern_to_bool(string=widest_walkway_dir, pattern="N"),
        widest_walkway_S = pattern_to_bool(string=widest_walkway_dir, pattern="S"),
        widest_walkway_E = pattern_to_bool(string=widest_walkway_dir, pattern="E"),
        widest_walkway_W = pattern_to_bool(string=widest_walkway_dir, pattern="W")
    ) 

df %>%
    select(c(widest_walkway_dir, widest_walkway_N, widest_walkway_S, widest_walkway_E, widest_walkway_W))
```

```{r}
df <- 
    df %>%
    mutate(
        widest_walkway_NS = ifelse(
            (widest_walkway_E != 1 & widest_walkway_W != 1) &
            (widest_walkway_N == 1 | widest_walkway_S == 1), 
            1, 0
        ),
        widest_walkway_EW = ifelse(
            (widest_walkway_N != 1 & widest_walkway_S != 1) &
            (widest_walkway_E == 1 | widest_walkway_W == 1), 
            1, 0
        )
    )
    
df %>% select(c(widest_walkway_N, widest_walkway_S, widest_walkway_E, widest_walkway_W, widest_walkway_NS, widest_walkway_EW))
```

```{r}
df %>% filter(
    widest_walkway_W == 1 | widest_walkway_E == 1
) %>%
    select(widest_walkway_N, widest_walkway_S, widest_walkway_NS)
```


## Direction of Entrance

```{r}
df$peristyle_direction_from_main_entrance %>% unique()
```

Same setup here, 4 directional dummy variables

```{r}
df <- 
    df %>%
    mutate(peristyle_direction_from_main_entrance = ifelse(
        peristyle_direction_from_main_entrance == "not visible" | 
        peristyle_direction_from_main_entrance =="not visibile", 
            NA, peristyle_direction_from_main_entrance
    )) %>%
    mutate(
        per_dir_from_entr_N = pattern_to_bool(string=peristyle_direction_from_main_entrance, pattern="N"),
        per_dir_from_entr_S = pattern_to_bool(string=peristyle_direction_from_main_entrance, pattern="S"),
        per_dir_from_entr_E = pattern_to_bool(string=peristyle_direction_from_main_entrance, pattern="E"),
        per_dir_from_entr_W = pattern_to_bool(string=peristyle_direction_from_main_entrance, pattern="W")
    ) 

df %>%
    select(c(
        peristyle_direction_from_main_entrance, 
        per_dir_from_entr_N, per_dir_from_entr_S, per_dir_from_entr_E, per_dir_from_entr_W
    ))
```

```{r}
df <- 
    df %>%
    mutate(
        per_dir_from_entr_NS = ifelse(
            (per_dir_from_entr_E != 1 & per_dir_from_entr_W != 1) &
            (per_dir_from_entr_N == 1 | per_dir_from_entr_S == 1), 
            1, 0
        ),
        per_dir_from_entr_EW = ifelse(
            (per_dir_from_entr_N != 1 & per_dir_from_entr_S != 1) &
            (per_dir_from_entr_E == 1 | per_dir_from_entr_W == 1), 
            1, 0
        )
    )
    
df %>% select(c(
    per_dir_from_entr_N, per_dir_from_entr_S, per_dir_from_entr_E, per_dir_from_entr_W, 
    per_dir_from_entr_NS, per_dir_from_entr_EW
))
```

## Major Axis of Garden

Unsure which column this refers to

```{r}
df$alignment_with_atrium %>% unique()
```

## Orientation of Large Room

```{r}
df %>% select(c(largest_room_direction...77, largest_room_direction...123))
```

I believe 123 is the one we want to keep here.

```{r}
df <- 
    df %>%
    mutate(largest_room_dir = largest_room_direction...123) %>%
    mutate(
        large_room_dir_N = pattern_to_bool(string=largest_room_dir, pattern="N"),
        large_room_dir_S = pattern_to_bool(string=largest_room_dir, pattern="S"),
        large_room_dir_E = pattern_to_bool(string=largest_room_dir, pattern="E"),
        large_room_dir_W = pattern_to_bool(string=largest_room_dir, pattern="W")
    ) 

df %>%
    select(c(
        largest_room_dir, 
        large_room_dir_N, large_room_dir_S, large_room_dir_E, large_room_dir_W
    ))
```

## Combine everything into one smaller dataset

```{r}
large_room_dir_vars <- c(
    "large_room_dir_N", "large_room_dir_S", "large_room_dir_E", "large_room_dir_W"
)

per_dir_from_entr_vars <- c(
    "per_dir_from_entr_N", "per_dir_from_entr_S", "per_dir_from_entr_E", "per_dir_from_entr_W",
    "per_dir_from_entr_NS", "per_dir_from_entr_EW"
)

widest_walkway_dir_vars <- c(
    "widest_walkway_N", "widest_walkway_S", "widest_walkway_E", "widest_walkway_W",
    "widest_walkway_NS", "widest_walkway_EW"
)

misc <- c("id", "visible_from_entrance", "stone_used_in_column", "peristyle_size")

messing_around <- c("order", "corin", "log_peri_size")

model_vars = c(misc, messing_around, large_room_dir_vars, per_dir_from_entr_vars, widest_walkway_dir_vars)

df_model <- df %>%
    # Messing around ---
    mutate(order = na_if(order, "unknown")) %>%
    mutate(order = str_replace(order, "Corinthian at entrance", "Doric")) %>%
    mutate(order = str_replace(order, "Doric, Corinthian piers", "Doric")) %>%
    mutate(
        corin = pattern_to_bool(order, "(Corinthian|corinth)"),
        log_peri_size = I(log(peristyle_size))
    ) %>%
    filter(!is.na(corin)) %>%
    # End messing around ---
    select(model_vars)

df_model
```

## Exploration

```{r}
df_model %>% filter(corin == 1) %>% select(c(id, corin, order))
```

```{r}
df_model$corin %>% sum(na.rm = T)
```

### Checking number of corin == 1 when walkway and per dir exists

```{r}
df_model %>% filter(corin == 1 & !is.na(widest_walkway_N)) %>% select(c(id, corin, order))
```

```{r}
df_model %>% filter(corin == 1 & !is.na(per_dir_from_entr_N)) %>% select(c(id, corin, order))
```

Wee see here that per_dir_from_entr leaves a lot more corin 1's on the table. 

### Checking number of rows left when neither walkway or per dir can be NA

```{r}
df_model %>% filter(!is.na(widest_walkway_N) & !is.na(per_dir_from_entr_N))
```

Only 40 rows where BOTH of these sets of predictors aren't NA. 

# Modeling

```{r}
model <- glm(
    visible_from_entrance ~ log_peri_size + corin + stone_used_in_column, 
    family=binomial(link="logit"),
    data=df_model
)

summary(model)
```

```{r}
model
```


```{r}
skim(df_model)
```

```{r}
df_model %>% select(id, visible_from_entrance, order, corin) %>% dplyr::arrange(corin)
```

```{r}
df
```

## Log peristyle size as response

```{r}
model <- lm(
    log_peri_size ~ visible_from_entrance + corin + stone_used_in_column, 
    data=df_model
)

summary(model)
anova(model)
```

```{r}
aov(log_peri_size ~ visible_from_entrance + corin + stone_used_in_column, data = df_model) %>% summary()
```


## Correlation of widest walkways

```{r}
df_model %>%
    select(c(widest_walkway_E, widest_walkway_N, widest_walkway_S, widest_walkway_W)) %>%
    cor(use='complete.obs')
```

## Correlation of Peristyle direction from entrance

```{r}
df_model %>%
    select(
        c(
            c(per_dir_from_entr_N, per_dir_from_entr_S, per_dir_from_entr_E, per_dir_from_entr_W),
            c(widest_walkway_N, widest_walkway_S, widest_walkway_E, widest_walkway_W)
        )
    ) %>%
    cor(use='complete.obs')
```


## Using widest walkways in model

We don't want to use all 4 so I'll use a for loop to examine which (if any) performs well.

```{r}

for (widest_walkway_dir in widest_walkway_dir_vars) {
    model <- glm(
        visible_from_entrance ~ log_peri_size + corin + stone_used_in_column + eval(parse(text=widest_walkway_dir)), 
        family=binomial(link="logit"),
        data=df_model
    )
    
    writeLines("\n\n")
    print(glue("--- [Model using {widest_walkway_dir}] ---"))
    
    print(summary(model))
    
    print(anova(model))
}
```

Seems walkway direction destroys the degrees of freedom and the model entirely. 


```{r}
for (widest_walkway_dir in widest_walkway_dir_vars) {
    model <- lm(
        log_peri_size ~ visible_from_entrance + corin + stone_used_in_column + eval(parse(text=widest_walkway_dir)), 
        data=df_model
    )
    
    writeLines("\n\n")
    print(glue("\n\n--- [Model using {widest_walkway_dir}] ---"))
    
    print(summary(model))
    
    print(anova(model))
}
```


## Using peristyle direction from entrance

```{r}
for (per_dir in per_dir_from_entr_vars) {
    model <- glm(
        visible_from_entrance ~ log_peri_size + corin + stone_used_in_column + eval(parse(text=per_dir)), 
        family=binomial(link="logit"),
        data=df_model
    )
    
    writeLines("\n\n")
    print(glue("\n\n--- [Model using {per_dir}] ---"))
    
    print(summary(model))
}
```

```{r}
for (per_dir in per_dir_from_entr_vars) {
    model <- lm(
        log_peri_size ~ visible_from_entrance + corin + stone_used_in_column + eval(parse(text=per_dir)), 
        data=df_model
    )
    
    writeLines("\n\n")
    print(glue("--- [Model using {per_dir}] ---"))
    
    print(summary(model))
    
    print(anova(model))
}
```


# Next steps
- Investigate discrepency between my and study dataset
- add distance from dyhr's dataset
- add in $X_{EW}$ and $X_{NS}$ variables
- change "not visible" w/ no directions to NA
- google AIC