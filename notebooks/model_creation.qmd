---
title: "Creating Model"
author: "Brady Lamson"
format: pdf
---

# Import Packages

```{r}
library(stringr)
library(dplyr)
library(skimr)
library(readxl)
library(glue)
library(ggplot2)
library(tidyr)
library(readr)
source('../helpers.R')
library(skimr)
```

# Import Data

```{r}
load_preprocessed <- TRUE

data_date <- "data/sep_13"

if (load_preprocessed) {
    data_path <- "pompei_preprocessed.csv"
    full_path <- paste0("../", data_date, "/", data_path)
    df <- readr::read_csv(full_path)
} else {
    data_path <- "Pompeii data 2023 for stats .xlsx"
    full_path <- paste0(data_date, "/", data_path) 
    df <- readxl::read_excel(full_path, sheet="all peristyles")
    df <- fix_variable_names(df)
    df <- create_unique_id(df)
}

sides <- 
    df %>%
    select(c(id, walkway_N, walkway_S, walkway_E, walkway_W)) %>%
    # Remove all rows where all 4 columns are NA
    filter(rowSums(!is.na(.)) > 1) %>%
    # Replace all remaining NAs with 0
    replace(is.na(.), 0) %>%
    mutate(walkway_count = rowSums(across(where(is.numeric))))

df
```

# Cleaning Required Columns

The columns we'll want to include in our model are as follows:

- Visibility from entrance
- Peristyle Size
- Column Material (stone/masonry boolean)
- Widest Walkway orientation
- Direction of Entrance
- Major Axis of Garden
- Orientation of large room (large room on axis)

## Visibility from entrance

### Possible Values

```{r}
df$`visible_from_entrance?` %>% unique()
```

We can make this a quick yes/no boolean


```{r}
df <- 
    df %>% 
    mutate(
        visible_from_entrance = pattern_to_bool(string=`visible_from_entrance?`, pattern="yes")
    )

df %>% select(c(`visible_from_entrance?`, visible_from_entrance))
```

## Peristyle size

```{r}
df$peristyle_size
```

This column is already totally usable.

## Column Material

This one requires some love, every row is unique text basically. We only care if a column has either stone or masonry and will design a boolean around that.

```{r}
df$column_material %>% head()
```

```{r}

df <- 
    df %>% 
    mutate(
        stone_used_in_column = pattern_to_bool(string=column_material, pattern="(stone|masonry)")
    )

df %>% select(c(stone_used_in_column, column_material))
```

## Widest Walkway Orientation

```{r}
df$widest_walkway_dir %>% unique()
```

Here I think the best call is to create 4 dummy variables much like for walkways and peristyles

```{r}
df <- 
    df %>%
    mutate(
        widest_walkway_N = pattern_to_bool(string=widest_walkway_dir, pattern="N"),
        widest_walkway_S = pattern_to_bool(string=widest_walkway_dir, pattern="S"),
        widest_walkway_E = pattern_to_bool(string=widest_walkway_dir, pattern="E"),
        widest_walkway_W = pattern_to_bool(string=widest_walkway_dir, pattern="W")
    ) 

df %>%
    select(c(widest_walkway_dir, widest_walkway_N, widest_walkway_S, widest_walkway_E, widest_walkway_W))
```

```{r}
df <- 
    df %>%
    mutate(
        widest_walkway_NS = ifelse(
            (widest_walkway_E != 1 & widest_walkway_W != 1) &
            (widest_walkway_N == 1 | widest_walkway_S == 1), 
            1, 0
        ),
        widest_walkway_EW = ifelse(
            (widest_walkway_N != 1 & widest_walkway_S != 1) &
            (widest_walkway_E == 1 | widest_walkway_W == 1), 
            1, 0
        )
    )
    
df %>% select(c(widest_walkway_N, widest_walkway_S, widest_walkway_E, widest_walkway_W, widest_walkway_NS, widest_walkway_EW))
```

```{r}
df %>% filter(
    widest_walkway_W == 1 | widest_walkway_E == 1
) %>%
    select(widest_walkway_N, widest_walkway_S, widest_walkway_NS)
```


## Direction of Entrance

```{r}
df$peristyle_direction_from_main_entrance %>% unique()
```

Same setup here, 4 directional dummy variables

```{r}
df <- 
    df %>%
    mutate(peristyle_direction_from_main_entrance = ifelse(
        peristyle_direction_from_main_entrance == "not visible" | 
        peristyle_direction_from_main_entrance =="not visibile", 
            NA, peristyle_direction_from_main_entrance
    )) %>%
    mutate(
        per_dir_from_entr_N = pattern_to_bool(string=peristyle_direction_from_main_entrance, pattern="N"),
        per_dir_from_entr_S = pattern_to_bool(string=peristyle_direction_from_main_entrance, pattern="S"),
        per_dir_from_entr_E = pattern_to_bool(string=peristyle_direction_from_main_entrance, pattern="E"),
        per_dir_from_entr_W = pattern_to_bool(string=peristyle_direction_from_main_entrance, pattern="W")
    ) 

df %>%
    select(c(
        peristyle_direction_from_main_entrance, 
        per_dir_from_entr_N, per_dir_from_entr_S, per_dir_from_entr_E, per_dir_from_entr_W
    ))
```

```{r}
df <- 
    df %>%
    mutate(
        per_dir_from_entr_NS = ifelse(
            (per_dir_from_entr_E != 1 & per_dir_from_entr_W != 1) &
            (per_dir_from_entr_N == 1 | per_dir_from_entr_S == 1), 
            1, 0
        ),
        per_dir_from_entr_EW = ifelse(
            (per_dir_from_entr_N != 1 & per_dir_from_entr_S != 1) &
            (per_dir_from_entr_E == 1 | per_dir_from_entr_W == 1), 
            1, 0
        )
    )
    
df %>% select(c(
    per_dir_from_entr_N, per_dir_from_entr_S, per_dir_from_entr_E, per_dir_from_entr_W, 
    per_dir_from_entr_NS, per_dir_from_entr_EW
))
```

## Major Axis of Garden

Unsure which column this refers to

```{r}
df$alignment_with_atrium %>% unique()
```

## Orientation of Large Room

```{r}
df %>% select(c(largest_room_direction...77, largest_room_direction...123))
```

I believe 123 is the one we want to keep here.

```{r}
df <- 
    df %>%
    mutate(largest_room_dir = largest_room_direction...123) %>%
    mutate(
        large_room_dir_N = pattern_to_bool(string=largest_room_dir, pattern="N"),
        large_room_dir_S = pattern_to_bool(string=largest_room_dir, pattern="S"),
        large_room_dir_E = pattern_to_bool(string=largest_room_dir, pattern="E"),
        large_room_dir_W = pattern_to_bool(string=largest_room_dir, pattern="W")
    ) 

df %>%
    select(c(
        largest_room_dir, 
        large_room_dir_N, large_room_dir_S, large_room_dir_E, large_room_dir_W
    ))
```

## Combine everything into one smaller dataset

```{r}
large_room_dir_vars <- c(
    "large_room_dir_N", "large_room_dir_S", "large_room_dir_E", "large_room_dir_W"
)

per_dir_from_entr_vars <- c(
    "per_dir_from_entr_N", "per_dir_from_entr_S", "per_dir_from_entr_E", "per_dir_from_entr_W",
    "per_dir_from_entr_NS", "per_dir_from_entr_EW"
)

widest_walkway_dir_vars <- c(
    "widest_walkway_N", "widest_walkway_S", "widest_walkway_E", "widest_walkway_W",
    "widest_walkway_NS", "widest_walkway_EW"
)

misc <- c("id", "visible_from_entrance", "stone_used_in_column", "peristyle_size")

messing_around <- c("order", "corin", "log_peri_size")

model_vars = c(misc, messing_around, large_room_dir_vars, per_dir_from_entr_vars, widest_walkway_dir_vars)

df_model <- df %>%
    # Messing around ---
    mutate(order = na_if(order, "unknown")) %>%
    mutate(order = str_replace(order, "Corinthian at entrance", "Doric")) %>%
    mutate(order = str_replace(order, "Doric, Corinthian piers", "Doric")) %>%
    mutate(
        corin = pattern_to_bool(order, "(Corinthian|corinth)"),
        log_peri_size = I(log(peristyle_size))
    ) %>%
    filter(!is.na(corin)) %>%
    # End messing around ---
    select(model_vars)

df_model
```
## Exploration

```{r}
df_model %>% filter(corin == 1) %>% select(c(id, corin, order))
```

```{r}
df_model$corin %>% sum(na.rm = T)
```

### Checking number of corin == 1 when walkway and per dir exists

```{r}
df_model %>% filter(corin == 1 & !is.na(widest_walkway_N)) %>% select(c(id, corin, order))
```

```{r}
df_model %>% filter(corin == 1 & !is.na(per_dir_from_entr_N)) %>% select(c(id, corin, order))
```

Wee see here that per_dir_from_entr leaves a lot more corin 1's on the table. 

### Checking number of rows left when neither walkway or per dir can be NA

```{r}
df_model %>% filter(!is.na(widest_walkway_N) & !is.na(per_dir_from_entr_N))
```

Only 40 rows where BOTH of these sets of predictors aren't NA. 

# Modeling

```{r}
model <- glm(
    visible_from_entrance ~ log_peri_size + corin + stone_used_in_column, 
    family=binomial(link="logit"),
    data=df_model
)

summary(model)
```

```{r}
model
```


```{r}
skim(df_model)
```

```{r}
df_model %>% select(id, visible_from_entrance, order, corin) %>% dplyr::arrange(corin)
```

```{r}
df
```

## Log peristyle size as response

```{r}
model <- lm(
    log_peri_size ~ visible_from_entrance + corin + stone_used_in_column, 
    data=df_model
)

summary(model)
anova(model)
```

```{r}
aov(log_peri_size ~ visible_from_entrance + corin + stone_used_in_column, data = df_model) %>% summary()
```


## Correlation of widest walkways

```{r}
df_model %>%
    select(c(widest_walkway_E, widest_walkway_N, widest_walkway_S, widest_walkway_W)) %>%
    cor(use='complete.obs')
```

## Correlation of Peristyle direction from entrance

```{r}
df_model %>%
    select(
        c(
            c(per_dir_from_entr_N, per_dir_from_entr_S, per_dir_from_entr_E, per_dir_from_entr_W),
            c(widest_walkway_N, widest_walkway_S, widest_walkway_E, widest_walkway_W)
        )
    ) %>%
    cor(use='complete.obs')
```


## Using widest walkways in model

We don't want to use all 4 so I'll use a for loop to examine which (if any) performs well.

```{r}

for (widest_walkway_dir in widest_walkway_dir_vars) {
    model <- glm(
        visible_from_entrance ~ log_peri_size + corin + stone_used_in_column, 
        family=binomial(link="logit"),
        data=df_model
    )
    
    writeLines("\n\n")
    print(glue("--- [Model using {widest_walkway_dir}] ---"))
    
    print(summary(model))
    
    print(anova(model))
}
```

Seems walkway direction destroys the degrees of freedom and the model entirely. 


```{r}
for (widest_walkway_dir in widest_walkway_dir_vars) {
    model <- lm(
        log_peri_size ~ visible_from_entrance + corin + stone_used_in_column + eval(parse(text=widest_walkway_dir)), 
        data=df_model
    )
    
    writeLines("\n\n")
    print(glue("\n\n--- [Model using {widest_walkway_dir}] ---"))
    
    print(summary(model))
    
    print(anova(model))
}
```


## Using peristyle direction from entrance

```{r}
for (per_dir in per_dir_from_entr_vars) {
    model <- glm(
        visible_from_entrance ~ log_peri_size + corin + stone_used_in_column + eval(parse(text=per_dir)), 
        family=binomial(link="logit"),
        data=df_model
    )
    
    writeLines("\n\n")
    print(glue("\n\n--- [Model using {per_dir}] ---"))
    
    print(summary(model))
}
```

```{r}
for (per_dir in per_dir_from_entr_vars) {
    model <- lm(
        log_peri_size ~ visible_from_entrance + corin + stone_used_in_column + eval(parse(text=per_dir)), 
        data=df_model
    )
    
    writeLines("\n\n")
    print(glue("--- [Model using {per_dir}] ---"))
    
    print(summary(model))
    
    print(anova(model))
}
```


# Next steps
- Investigate discrepency between my and study dataset
- add distance from dyhr's dataset
- add in $X_{EW}$ and $X_{NS}$ variables
- change "not visible" w/ no directions to NA
- google AIC

## Investigating ---
```{r}
df %>% head()
```

## Next Steps Oct 26

### Table

```{r}
mytable <- table(df_model$corin, df_model$stone_used_in_column)
colnames(mytable) <- c("no stone", "stone")
rownames(mytable) <- c("not corinthian", "corinthian")
mytable
```

Consider a new variable that is boolean.
0 if not corinthian & not stone
1 otherwise

### Try different link functions
Don't worry about interpretation, but give them a try

# Create distance variable
## Load in location data
```{r}
location_data <- read_xlsx("../data/oct_26/10_26_13_SSP.xlsx")
# Remove the rows that aren't included in the model.
location_data <- location_data[1:149,]
```

## Calculate distance from ampitheater
Here he use the `distGeo` library to give us the exact geo-distance in meters that each house is from the ampitheater. 

We divide by 1000 at the end to convert to kilometers.

```{r}
library(geosphere)
# These are the coordinates of the ampitheatre in pompeii
ampitheater <- c(40.7512, 14.4952)
location_data <-
    location_data %>% 
    mutate(
        dist_from_ampi = mapply(
            # Here we create an anonymous function to apply the distgeo function to each lat,long pair per row
            function(x, y) distGeo(p1=c(x, y), p2=ampitheater) / 1000, lat, long
        )
    ) %>%
    rename(number = hid) #%>%
    # create_unique_id()

# create_unique_id(location_data)
# location_data %>% create_unique_id()
```

```{r}
# Confirm this works identical to Dyhr's solution
# mylist <- rep(0, nrow(location_data))
# for (index in 1:nrow(location_data)) {
#     mylist[index] <- distGeo(
#         c(location_data$lat[index], location_data$long[index]),
#         ampitheater
#     )
# }
# location_data$dist_from_ampi <- mylist
# location_data
```

# Create NS/EW dominant walkway vars

```{r}
# My old convoluted means of checking if a vector is in a list of vectors, saved for posterity. 
check <- c(1,2) 
listofvec <- list(check, c(3,4))
any(sapply(listofvec, function(x) identical(x, check)))
```



```{r}
no_orient <- list(
    c(1, 0, 1, 0),
    c(0, 1, 0, 1),
    c(0, 0, 0, 0),
    c(1, 1, 1, 1),
    c(1, 0, 0, 1),
    c(0, 1, 1, 0)
)
ns_dom <- list(
    c(1, 1, 0, 1),
    c(0, 1, 0, 0),
    c(1, 0, 0, 0),
    c(1, 1, 1, 0),
    c(1, 1, 0, 0)
)
ew_dom <- list(
    c(0, 0, 1, 1),
    c(1, 0, 1, 1),
    c(0, 1, 1, 1),
    c(0, 0, 0, 1),
    c(0, 0, 1, 0)
)    
```

```{r}
# Some sanity checks
list(c(1,0,1,0)) %in% no_orient
list(c(1,0,1,0)) %in% ns_dom
list(c(1,0,1,0)) %in% ew_dom
```

```{r}
# This function makes what'd be a huge chunk of code way less repetitive.
# Essentially what this does is check if the vector made up by the NSEW walkway columns
# is in the orientation dominance list of vectors. 
# I use mapply here which is the multivariate version of apply to use all 4 columns as variables.
apply_comparison <- function(df, list_name, comparison_list) {
    df %>%
        mutate(
            !!list_name := mapply(
                function(n, s, e, w) as.integer(list(c(n, s, e, w)) %in% comparison_list),
                walkway_N, walkway_S, walkway_E, walkway_W
            )
        )
}
```


```{r}
# Test on this dataset real quick
walkway_df <- readr::read_csv("../data/walkway_and_portico_directions.csv")
```

```{r}
walkway_df <- 
    walkway_df %>%
    apply_comparison("no_orient", no_orient) %>%
    apply_comparison("ns_dom", ns_dom) %>%
    apply_comparison("ew_dom", ew_dom) 

walkway_df %>%
    select(walkway_N, walkway_S, walkway_E, walkway_W, no_orient, ns_dom, ew_dom)
```

```{r}
df_model <- left_join(df_model, walkway_df, by="id")
```

```{r}
df_model$id
```

